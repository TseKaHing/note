## OSI 七层模型

1. 应用层
   针对特定应用规定各层协议时序表示等进行封装，如 http
   （ Telnet，FTP,SMTP,SNMP ） 报文 SSH（安全外壳协议）为应用层基础上的安全协议
2. 表示层
   数据格式转换
3. 会话层
   规定通信时序，创建检查点
4. 运输层
   发送可靠数据
   （TCP,UDP,UGP）数据报
5. 网络层
   路由寻址，拥塞控制，分组交换
   （IP,ICMP,IGMP）
6. 数据链路层
   CRC 纠错
   （ARP,RARP）帧
7. 物理层
   机械特性，电气特性
   字节流

## TCP 和 UDP 区别

1. TCP 可以超时重传，UDP 不可以
2. TCP 可以进行可靠传输，UDP 不可以
3. TCP 提供流量控制，UDP 不提供
4. TCP 面向连接，字节流服务，UDP 面向报文
5. TCP 传输速度较 UDP 慢
6. TCP 连接较 UDP 安全可靠，UDP 可能会丢包
7. TCP 首部（20Byte），只能一对一传输，UDP 首部（8Byte），支持一对一传输，可支持一对多传输

## HTTP 1.0 1.1 2.0

影响网络的主要因素：带宽、延迟（最重要因素）

### HTTP 1.0

浏览器每次请求都要建立一个 TCP 连接，服务器完成请求后立即断开 TCP 连接
客户端根据域名来向服务器建立连接，一般 PC 端浏览器会针对单个域名的 server 同时建立 6-8 个连接，手机端 4-6 个

1. 不支持持久性连接,只支持短暂性连接
2. 连接无法复用，线头阻塞
3. 上一次请求和下一次请求完全分离
4. 连接建立和断开非常耗时，严重影响服务器性能
5. HTTP 1.0 需要使用 keep-alive 参数来告知服务器要建立一个长连接

### HTTP 1.1

HTTP 1.1 支持持久性连接，在一个 TCP 连接上可以传送多个 HTTP 请求和 响应，减少了 TCP 连接和断开的性能消耗

1. 支持持久性连接，一个 TCP 连接上可以传送多个 HTTP 请求和响应
2. 增加 HOST 字段，可以表示访问服务器的 IP
3. 增加 Cache-Control 首部字段，缓存机制更加灵活强大
4. 增加 Content-Range 首部字段，实现带宽优化
5. 引入管道方式，支持多请求发送
6. 新增多种请求方式：OPTIONS、TRACE、CONNECT 等

### HTTP 2.0

HTTP 2.0 相比 HTTP 1.1 极大地提升了性能

1. HTTP 首部压缩
2. 支持服务端推送
3. 多路复用（多个请求可同时在一个连接上并行执行）
4. 采用二进制格式传输数据

### HTTP 3.0

引入谷歌主导开发的 QUIC 协议（快速 UDP 网络连接）
谷歌调优后的 QUIC 重建了可靠性和有序性

## HTTP 和 HTTPS 的区别

（ssl 证书是 ca 证书的一种，ca 是数字证书管理机构）

1. https = http + ssl
2. https 需要 ssl 证书，而 ssl 需要钱买，ssl 证书需要绑定 IP，一个 IP 绑定一个域名，IPV4 资源支持不了这种消耗
3. http 端口号 80，https 端口号 443
4. http 明文传输，无状态（协议对事物处理没有记忆能力），无连接（每次连接只处理一个请求）
5. https 握手更费事，也更耗电
6. https 缓存不如 http 高效，https 会增加数据开销

## HTTPS 握手过程

## HTTPS 工作原理

1. 客户端 --> 服务端
   客户端通过 HTTPS URL 去访问服务器，要求 WEB 服务建立 SSL 连接
2. 客户端 <-- 服务端
   服务端收到客户端的连接请求，返回该网站 CA 证书的公钥
3. 客户端 <--> 服务端
   客户端和服务端协商 SSL 连接的安全等级（加密等级）

4. 客户端 --> 服务端
   客户端通过协商的安全等级生成会话秘钥，然后通过网站的公钥去加密会话秘钥，并发送信息给服务端
5. 客户端 <-- 服务端
   服务端通过网站 CA 证书的私钥去解密用网站 CA 证书公钥加密后的会话秘钥
6. 客户端 <--> 服务端
   客户端通过 CA 证书公钥加密，服务端通过 CA 证书私钥解密的形式进行客户端和服务端之间进行通信

## 在浏览器地址输入 url 到显示页面这个过程发生了什么？

1. 判断是否有地址重定向（301）
2. 浏览器解析 url，获取协议，域名, 端口号，路径等 304 强缓存、协商缓存
3. DNS 解析（查缓存）找 IP
   3.1 查浏览器缓存
   3.2 查本地缓存
   3.3 向本地域名解析服务发起域名解析的请求
   3.4 向根域名解析服务器发起域名解析请求
4. TCP 三次握手
5. TCP 连接后发送 HTTP 请求
6. 服务端验证请求
7. 查询数据库等操作
8. 客户端接收 HTTP 响应
9. 获取 html，构建 DOM 树
10. 根据 CSS 等样式构建 render 树，此时的 render 树不包含定位和几何信息（重绘）
11. 构建布局树，布局树包含定位和几何信息（回流）
12. 解析 js
13. TCP 四次挥手

## TCP 三次握手，四次挥手

### TCP 三次握手

1. 第一次：
   客户端 --> 服务端
   客户端向服务端发起连接请求，SYN=1，seq=x

2. 第二次：
   客户端 <-- 服务端
   客户端收到服务端的连接请求，SYN=1，ACK=1，seq=y，ack=x+1

3. 第三次：
   客户端 --> 服务端
   客户端收到服务端的连接请求确认，此时客户端向服务端发送收到服务端请求确认的信号，ACK=1，seq=x+1，ack=y+1

### TCP 四次挥手

1. 第一次：
   客户端 --> 服务端
   客户端向服务端发起中断请求，FIN=1，seq=u

2. 第二次：
   客户端 <-- 服务端
   服务端收到客户端的中断请求，ACK=1，seq=v，ack=u+1，此时客户端可以继续接收服务端发送过来的数据

3. 第三次：
   客户端 <-- 服务端
   当客户端收到服务端发送过来的信号，FIN=1，ACK=1，seq=w，ack=u+1，此时确认可以断开连接，表示确认数据传输完毕

4. 第四次：
   客户端 --> 服务端
   客户端收到服务端的确认传输完毕，也发送 ACK=1，seq=u+1，ack=w+1，表示客户端断开 TCP 连接

## websocket

1. websocket 是 HTML5 新增的协议，并支持持久性的连接，而 http 不支持持久性连接
2. http 中，一个 req,对于一个 res，res 是被动的，而 websocket 允许服务端主动想客户端推送数据
3. 在 websocket API 中，浏览器和服务器只需要完成一次握手，就可以创建持久性连接，并进行双向数据传输

## SSH（安全外壳协议）

SSH 是在应用层基础上的安全协议
SSH 是目前较可靠的，专为远程登录会话和其它网络服务提供提供安全性的协议
PS：FTP、TELNET 等本质上不安全（明文传输口令和数据），容易受到“中间人”攻击

从客户端来看，SSH 主要提供两种级别的安全验证：

1. 基于账号和口令的安全验证
   只需要知道账号和口令，就可以登录到远程主机，所有传输的数据都会被加密，但是不能保证你正在连接的服务器就是你想连接的那台服务器，可能有冒充的服务器

2. 基于秘钥
   一、 客户端向服务器发起访问请求
   二、 服务端在服务器主目录下寻找公钥
   三、 客户端和服务端进行公钥的比对和验证
   四、 如果比对正确，服务端向客户端发起质询，并把服务端的公钥发送给客户端
   五、 客户端对服务端的公钥，用客户端的私钥解开服务端的公钥，再把私钥发送给服务端

## 状态码

### 分类

`1**` 信息，服务器收到请求，需要请求者继续执行操作
`2**` 成功，操作被成功接收并处理
`3**` 重定向，需要进一步的操作以完成请求
`4**` 客户端错误，请求包含语法错误或无法完成请求
`5**` 服务器错误，服务器在处理请求的过程中发生了错误

### 常用状态码

`100` `Continue` 继续，客户端应该继续其请求
`200` `OK` 请求成功，一般用于 GET/POST 请求
`301` `Moved Permanently` 永久重定向
`302` `Found` 临时重定向
`304` `Not Modified` 未修改，所请求的资源没有修改，意为可以直接使用客户端的资源 状态码 304（强缓存和协商缓存）  
`305` `Use Proxy` 使用代理，所请求的资源必须通过代理访问
`400` `Bad Request` 客户端请求的语法错误，服务器无法解析
`401` `Unauthorized` 未授权，请求要求用户的身份验证（比如 token）
`404` `Not Found` 找不到资源，服务器无法根据客户端的请求找到资源
`500` `Internal Server Error` 服务器内部错误，无法完成请求
`502` `Bad Gateway` 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的请求

### 304 缓存过程（除了 Etag 还有什么）

304 状态码
未修改。
自从上次请求之后，请求的网页未修改
服务器返回该状态码时，不会返回网页内容
节省浏览器带宽和开销

## 永久重定向（301）和临时重定向（302）

301 重定向可促进搜索引擎优化效果
302 重定向可影响搜索引擎优化效果

### 分别在什么场景用？

301 适合永久重定向
比较常用的场景是做域名跳转。
比如访问http://veryyoung.github.io会重定向到http://veryyoung.me

302 用来做临时跳转
比如未登陆的用户访问用户中心重定向到登陆页面。访问 404 页面会自动重定向到首页。

## DNS 解析

域名解析就是把域名解析成 IP

### 解析过程

1. 查浏览器缓存
   当用户通过浏览器访问某域名时，从浏览器缓存中找 IP
2. 查系统缓存
   当浏览器缓存中无域名对应 IP，则会自动检查用户计算机系统 Hosts 文件 DNS 缓存是否有该域名对应 IP
3. 查路由器缓存
   当浏览器及系统缓存中均无域名对应 IP 则进入路由器缓存中检查，以上三步均为客服端的 DNS 缓存
4. 查 ISP（互联网服务提供商）DNS 缓存
   当在用户客服端查找不到域名对应 IP 地址，则将进入 ISP DNS 缓存中进行查询 比如：电信
5. 查根域名服务器缓存
   当以上均未完成，则进入根服务器进行查询。全球仅有 13 台根域名服务器，1 个主根域名服务器，其余 12 为辅根域名服务器
6. 查顶级域名服务器缓存
   顶级域名服务器收到请求后查看区域文件记录，若无则将其管辖范围内主域名服务器的 IP 地址告诉本地 DNS 服务器
7. 查主域名服务器缓存
   主域名服务器接受到请求后查询自己的缓存，如果没有则进入下一级域名服务器进行查找，并重复该步骤直至找到正确纪录
8. 保存结果至缓存
   本地域名服务器把返回的结果保存到缓存，以备下一次使用，同时将该结果反馈给客户端，客户端通过这个 IP 地址与 web 服务器建立链接

## HTTP 缓存

1. 强缓存 直接从缓存中读取资源，强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control
   1.1 Expires
   1.1.1 缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点
   1.1.2 Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效
   1.2 Cache-Control
   1.2.1 HTTP/1.1 中，Cache-Control 是最重要的规则，主要用于控制网页缓存
   1.3 Expires 和 Cache-Control 区别
   1.3.1 两者同时存在的话，Cache-Control 优先级高于 Expires
2. 协商缓存 强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况
   2.1 协商缓存生效，返回 304 和 Not Modified
   2.2 协商缓存失效，返回 200 和请求结果

   协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag
   在精确度上，Etag 要优于 Last-Modified
   Last-Modified 的时间单位是秒，如果某个文件在 1 秒内改变了多次，那么他们的 Last-Modified 其实并没有体现出来修改，但是 Etag 每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的 Last-Modified 也有可能不一致
   在性能上，Etag 要逊于 Last-Modified
   Last-Modified 只需要记录时间，而 Etag 需要服务器通过算法来计算出一个 hash 值
   在优先级上，服务器校验优先考虑 Etag
